package p1849;

import java.nio.charset.StandardCharsets;
import java.util.Scanner;

public class CF1849D {
    static int n;
    static int[] a;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in, StandardCharsets.UTF_8);
        n = scanner.nextInt();
        a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }
        System.out.println(solve());
    }

    private static String solve() {
        int l = 0, ans = 0;
        while (l < n) {
            int r = l + 1;
            boolean hasTwo = (a[l] == 2);
            boolean hasMiddleZero = false;
            while (r < n) {
                if (r - 1 > l && a[r - 1] == 0) {
                    hasMiddleZero = true;
                }
                if (a[r] == 2) {
                    hasTwo = true;
                }
                boolean good = !hasMiddleZero && (hasTwo || a[l] != 0 || a[r] != 0);
                if (!good) {
                    break;
                }
                r++;
            }
            l = r;
            ans++;
        }
        return String.valueOf(ans);
    }
}
/*
D. Array Painting
https://codeforces.com/contest/1849/problem/D

题目大意：
给定一个 n 个整数的数组，其中每个整数要么为 0，要么为 1，要么为 2。最初，数组的每个元素都是蓝色的。
您的目标是将数组的每个元素涂成红色。为此，您可以执行两种类型的操作:
- 花一枚硬币选择一个蓝色元素并将其涂成红色;
- 选择一个不等于 0 的红色元素及其相邻的蓝色元素，将选中的红色元素减 1，并将选中的蓝色元素涂成红色。
你需要花费多少硬币才能达到目标?

rating 1700
dp？
---
https://codeforces.com/blog/entry/118752
假设我们使用了如下的第二个操作:减少一个红色元素 x，并将另一个元素 y 涂成红色。我们设 x 是 y 的父向量。
更进一步，假设如果满足以下两个条件之一，元素 x 控制元素 y:
- X 是 y 的父结点;
- X 控制 y 的父节点。
现在，假设我们用硬币把一些元素涂成红色。对于这些元素中的每一个，都存在一段它所控制的红色元素。所以，这个问题实际上可以重新表述如下:我们想把给定的数组分成最小数量的片段，这样每个片段都可以用一个硬币来画。如果数组的某一部分只用一个硬币就能画出来，我们就称它为好。
为了继续我们的解决方案，我们需要以下性质:如果一个线段是好的，那么它的每一个子线段也是好的。这有点直观，但如果你对正式证明感兴趣，你可以阅读下面的段落。
形式证明:我们需要考虑两种主要情况:控制主要部分的元素属于我们分析的子部分，或者不属于我们分析的子部分。在第一种情况下，证明很简单:我们可以用一枚硬币把子部分的所有元素涂成红色，就像我们把整个部分涂成红色一样，从控制它的元素开始。在第二种情况下，它有点困难，但不是控制主段的元素，我们可以从子段的最左边的元素开始，也可以从子段的最右边的元素开始——这取决于这个子段是在控制整个段的元素的右边还是左边。这个起始元素将通过花费一枚硬币而被涂成红色，子线段的所有其他元素都可以以与整个线段相同的方式被涂成红色。
因为如果一个段是好的，它的每一个子段也是好的，我们可以使用下面的贪心方法来解决这个问题:从只包含数组第一个元素的段开始，向右扩展，直到它变成坏的。当这个段不再是好的，我们需要开始一个新的段，我们将再次向右扩展，直到它变得不好，以此类推。那么数组的每个元素将只被考虑一次。如果我们设计一种方法，当我们在 O(1)中添加一个新元素时，确定该段是否仍然是好的，那么我们的解决方案将在 O(n)中有效。
剩下的就是分析如何检查分段是否良好。有多种方法可以做到这一点。模型解决方案中使用的方法采用以下思想:
- 线段中间不能有任何 0，因为如果我们从 0 的左边开始涂红色，我们就无法到达 0 右边的元素，反之亦然;
- 如果中间没有零，并且至少有一个端点不为零，那么这个线段就是好的因为我们可以从这个端点开始扩展到另一个端点;
- 如果中间没有 0，并且至少有一个元素等于 2，我们可以首先将该元素涂成红色，并向左右扩展，直到我们到达该段的边界;
- 如果两个端点都是 0，但其他元素都是 1，很容易看出只用一枚硬币将整个线段涂成红色是不可能的:线段上元素的总和是 k−2，其中 k 是线段的长度，但我们需要在不花费硬币的情况下将至少 k−1 个元素涂成红色。
所有这些想法都允许我们使用几个 if 语句来验证片段是好的。
求解复杂度:O(n)。
======

input
3
0 2 0
output
1

input
4
0 0 1 1
output
2

input
7
0 1 0 0 1 0 2
output
4
 */
