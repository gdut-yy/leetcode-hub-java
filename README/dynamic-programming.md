# leetcode 动态规划入门

本文共 46 题

动态规划三部曲：状态定义、转移方程、初始状态

## 1. [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

```
斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。
0 <= n <= 30

状态定义：
dp[i] 表示第 i 个斐波那契数。
转移方程：
dp[i] = dp[i-1] + dp[i-2] (i>1)
初始状态：
dp[0] = 0
dp[1] = 1
```

## 2. [1137. 第 N 个泰波那契数](https://leetcode.cn/problems/n-th-tribonacci-number/)

```
泰波那契序列 Tn 定义如下：
T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2
给你整数 n，请返回第 n 个泰波那契数 Tn 的值。

状态定义：
dp[i] 表示第 i 个泰波那契数。
转移方程：
dp[i] = dp[i-1] + dp[i-2] + dp[i-3] (i>2)
初始状态：
dp[0] = 0
dp[1] = 1
dp[2] = 1
```

## 3. [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。

状态定义：
dp[i] 表示爬到第 i 个台阶有多少种不同的方法。
转移方程：
dp[i] = dp[i-1] + dp[i-2] (i>1)
初始状态：
dp[0] = 1
dp[1] = 1
```

## 4. [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

```
数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。
每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。
请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

状态定义：
dp[i] 表示爬到第 i 个台阶的最低花费。
转移方程：
dp[i] = min(dp[i-1] + cost[i-1]), (dp[i-2] + cost[i-2]) (i>1)
初始状态：
dp[0] = 0
dp[1] = 0
```

## 5. [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

```
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，
如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

状态定义：
dp[i] 表示到第 i 个房屋能够偷窃到的最高金额。
转移方程：
dp[i] = max(dp[i-1], (dp[i-2] + nums[i]) (i>1)
初始状态：
dp[0] = nums[0]
dp[1] = max(nums[0], nums[1])
```

## 6. [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

```
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。
同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

同198题，因为房屋围成一圈，取 [0,n-1] 与 [1,n] 最大值即可。
```

## 7. [740. 删除并获得点数](https://leetcode.cn/problems/delete-and-earn/)

```
给你一个整数数组 nums ，你可以对它进行一些操作。
每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。
开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

先求出每个 num 出现了 cnt 次，求和 sum[num] = num * cnt
同198题，若选取了 sum[num]，sum[num-1] 和 sum[num+1] 都不可再选取，取 rob(int[] sum) 最大值即可。
```

## 8. [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

```
给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标。

状态定义：
dp[i] 表示第 i 个下标可以跳跃的最大长度（包括经过下标 i 后剩余的长度）。
转移方程：
dp[i] = max(dp[i-1]-1, nums[i]) (i>0)
初始状态：
dp[0] = nums[0]
```

## 9. [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

```
给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
假设你总是可以到达数组的最后一个位置。

贪心
```

## 10. [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

```
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

状态定义：
dp[i] 表示以第 i 个数结尾的「连续子数组的最大和」。答案即 max(dp[i])
转移方程：
dp[i] = max(dp[i-1]+nums[i], nums[i]) (i>0)
初始状态：
dp[0] = nums[0]
```

## 11. [918. 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)

```
给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。
在此处，环形数组意味着数组的末端将会与开头相连呈环状。
（形式上，当0 <= i < A.length 时 C[i] = A[i]，且当 i >= 0 时 C[i+A.length] = C[i]）
此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。
（形式上，对于子数组 C[i], C[i+1], ..., C[j]，不存在 i <= k1, k2 <= j 其中 k1 % A.length = k2 % A.length）


```

## 12. [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

```
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

状态定义：
dpMax[i] 表示以第 i 个元素结尾的乘积最大子数组的乘积
dpMin[i] 表示以第 i 个元素结尾的乘积最小子数组的乘积（nums[i] 有可能为负数，希望这个积尽可能「负得更多」，即尽可能小）
转移方程：
dpMax[i] = max(dpMax[i-1]*nums[i], dpMin[i-1]*nums[i], nums[i])
dpMin[i] = min(dpMax[i-1]*nums[i], dpMin[i-1]*nums[i], nums[i])
初始状态：
dpMax = nums
dpMin = nums
```

## 13. [1567. 乘积为正数的最长子数组长度](https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/)

```
给你一个整数数组 nums，请你求出乘积为正数的最长子数组的长度。
一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。
请你返回乘积为正数的最长子数组长度。
```

## 14. [1014. 最佳观光组合](https://leetcode.cn/problems/best-sightseeing-pair/)

```
给你一个正整数数组 values，其中 values[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的 距离 为 j - i。
一对景点（i < j）组成的观光组合的得分为 values[i] + values[j] + i - j ，也就是景点的评分之和 减去 它们两者之间的距离。
返回一对观光景点能取得的最高分。
```

## 15. [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

```
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
```

## 16. [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

```
给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
```

## 17. []()

## 18. []()

## 19. [139. 单词拆分](https://leetcode.cn/problems/word-break/)

```
给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
说明：
拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
```

## 20. []()

## 21. []()

## 22. []()

## 23. []()

## 24. []()

## 25. []()

## 26. []()

## 27. []()

## 28. []()

## 29. []()

## 30. []()

## 31. []()

## 32. []()

## 33. []()

## 34. []()

## 35. []()

## 36. []()

## 37. []()

## 38. []()

## 39. []()

## 41. []()

## 42. []()

## 43. []()

## 44. []()

## 45. []()

## 46. []()

（全文完）